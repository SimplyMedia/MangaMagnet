/**
 * This code was generated by v0 by Vercel.
 * @see https://v0.dev/t/uGUPnQYKtXe
 */
import { ChapterMetadataResponse, ChapterResponse, MangaResponse, VolumeResponse } from "@/services/openapi";
import React, { useEffect, useState } from "react";
import { VolumeList } from "@/components/manga/volume/VolumeList";

const groupBy = <T, K extends keyof any>(list: T[], getKey: (item: T) => K) =>
	list.reduce((previous, currentItem) => {
		const group = getKey(currentItem);
		if (!previous[group]) previous[group] = [];
		previous[group].push(currentItem);
		return previous;
	}, {} as Record<K, T[]>);

export interface ChapterData {
	local: ChapterResponse;
	volume?: VolumeResponse;
	metadata: ChapterMetadataResponse;
	mangaId: string;
}

export function VolumeOverview({manga}: { manga: MangaResponse }) {
	const [items, setItems] = useState<ChapterData[][]>([]);

	useEffect(() => {
		const pairs = manga.chapterMetadata.map<ChapterData>(metadata => ({
			metadata,
			local: manga.chapters.find(c => c.chapterNumber === metadata.chapterNumber)!,
			mangaId: manga.id,
			volume: manga.volumes.find(v => v.volumeNumber === metadata.volumeNumber)
		}));

		const groups = groupBy(pairs, r => r.metadata.volumeNumber ?? -1);
		const items = Object.values(groups);

		items.sort((a, b) => (b[0]?.metadata.volumeNumber ?? Number.MAX_VALUE) - (a[1]?.metadata.volumeNumber ?? Number.MAX_VALUE))

		for (const array of items) {
			array.sort((a, b) => b.metadata.chapterNumber - a.metadata.chapterNumber);
		}

		setItems(items)
	}, [manga]);


	return (
		<div>
			{items.map(i => (
				<VolumeList key={i[0].metadata.volumeNumber} chapters={i} volume={i[0].volume}
							volumeNumber={i[0].metadata.volumeNumber}/>
			))}
		</div>
	)
}

